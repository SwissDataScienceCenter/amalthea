from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from dateutil import parser
from typing import Any, Dict, Optional

from controller.server_status_enum import ServerStatusEnum


@dataclass
class MetricEvent:
    """Every element in the metrics queue that is created by
    amalthea and consumed by the metrics handlers conforms to this
    structure."""

    event_timestamp: datetime
    session: Dict[str, Any]
    sessionCreationTimestamp: Optional[datetime] = None
    old_status: Optional[ServerStatusEnum] = None
    status: Optional[ServerStatusEnum] = None

    def __post_init__(self):
        if self.status and type(self.status) is str:
            self.status = ServerStatusEnum(self.status)
        if self.old_status and type(self.old_status) is str:
            self.old_status = ServerStatusEnum(self.old_status)
        if self.session.get("metadata", {}).get("creationTimestamp"):
            self.sessionCreationTimestamp = parser.isoparse(self.session.get("metadata", {}).get("creationTimestamp"))

    def __repr__(self) -> str:
        return (
            f"MetricEvent(event_timestamp={self.event_timestamp}, old_status={self.old_status}, "
            f"status={self.status}, sessionCreationTimestamp={self.sessionCreationTimestamp}, "
            "session=<redacted>)"
        )


class MetricEventHandler(ABC):
    """Abstract class for the queue workers that will
    be doing the final publishing or persisting of any metrics
    that are generated by amalthea in the metrics queue."""

    @abstractmethod
    def publish(self, metric_event: MetricEvent):
        pass
